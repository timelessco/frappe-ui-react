{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "native-utils",
  "type": "registry:ui",
  "title": "Native Utils",
  "description": "A native utils component",
  "dependencies": [
    "react-native",
    "react-native-reanimated"
  ],
  "files": [
    {
      "path": "registry/native/default/lib/utils.ts",
      "content": "// @ts-nocheck\nimport React from \"react\";\nimport {\n\tFalsy,\n\tPressableStateCallbackType,\n\tRegisteredStyle,\n\tStyleProp,\n\tStyleSheet,\n\tViewStyle,\n} from \"react-native\";\n\n/**\n * The `cx` function in TypeScript filters out falsy values from an array of classNames and joins the\n * remaining values with a space.\n * @param {unknown[]} classNames - The `classNames` parameter is a rest parameter in TypeScript that\n * allows the `cx` function to accept an arbitrary number of arguments of type `unknown`. These\n * arguments represent CSS class names that will be filtered to remove any falsy values (such as\n * `null`, `undefined`, `false`, etc.)\n */\nexport const cx = (...classNames: unknown[]): string =>\n\tclassNames.filter(Boolean).join(\" \");\n\n/**\n * \"If the type of the value is a function, then return true, otherwise return false.\"\n *\n * The above function is a type guard. It's a function that takes a value and returns a boolean. If the\n * boolean is true, then the value is of the type that the type guard is guarding against\n * @param {any} value - any - The value to check.\n */\nconst isFunction = (value: any): value is Function =>\n\ttypeof value === \"function\";\n\n/**\n * Take from Chakra UI Util Funcs\n * https://github.com/chakra-ui/chakra-ui/blob/05b19899b02e17b4ee16045c9e5065fa835f0159/packages/components/theme/src/utils/run-if-fn.ts\n *\n * \"If the valueOrFn is a function, call it with the args and return the result, otherwise return the\n * valueOrFn.\"\n *\n * The function is generic, so it can be used with any type of valueOrFn and any number of args\n * @param {T | ((...fnArgs: U[]) => T)} valueOrFn - T | ((...fnArgs: U[]) => T)\n * @param {U[]} args - U[]\n * @returns A function that takes a value or a function and returns the value or the result of the\n * function.\n */\nfunction runIfFn<T, U>(\n\tvalueOrFn: T | ((...fnArgs: U[]) => T),\n\t...args: U[]\n): T {\n\treturn isFunction(valueOrFn) ? valueOrFn(...args) : valueOrFn;\n}\n\nexport const styleAdapter = (\n\tstyle:\n\t\t| StyleProp<ViewStyle>\n\t\t| ((state: PressableStateCallbackType) => StyleProp<ViewStyle>),\n\ttouchState?: PressableStateCallbackType,\n): ViewStyle | Falsy | RegisteredStyle<ViewStyle> => {\n\tconst _style = touchState ? runIfFn(style, touchState) : style;\n\tconst __style = !Array.isArray(_style) ? _style : StyleSheet.flatten(_style);\n\treturn __style as ViewStyle | Falsy | RegisteredStyle<ViewStyle>;\n};\n\n/**\n *\n * Types\n *\n */\nexport type Dict<T = unknown> = Record<string, T>;\n\nexport type DeepDictionary<K> = {\n\t[P in keyof K]: K[P] extends Dict\n\t\t? DeepDictionary<K[P]> & { [x: string]: unknown }\n\t\t: K[P];\n};\n\nexport type DeepPartial<T> = {\n\t[P in keyof T]?: DeepPartial<T[P]>;\n};\n\nexport type RenderPropType<T = unknown> =\n\t| React.ReactNode\n\t| ((args: T) => JSX.Element | React.ReactNode);\n\nexport type AnyObject = Record<keyof any, any>;\n\nexport type RenderProp<P = AnyObject> = (props: P) => React.ReactNode;\n\n// Merge library & user prop\nexport function passProps<T extends AnyObject = AnyObject, S = AnyObject>(\n\tcomponent: RenderPropType<S>,\n\tprops?: T,\n): React.ReactNode {\n\treturn React.isValidElement(component)\n\t\t? React.cloneElement(component, {\n\t\t\t\t...props,\n\t\t\t\t...component.props,\n\t\t\t})\n\t\t: // @ts-ignore\n\t\t\trunIfFn(component, { ...props });\n}\n\nexport type IconProps = { fill?: string; className?: string };\n\nexport function isUndefined(value: unknown): value is undefined {\n\treturn typeof value === \"undefined\" || value === undefined;\n}\n\nexport interface CreateContextOptions {\n\t/**\n\t * If `true`, React will throw if context is `null` or `undefined`\n\t * In some cases, you might want to support nested context, so you can set it to `false`\n\t */\n\tstrict?: boolean;\n\t/**\n\t * Error message to throw if the context is `undefined`\n\t */\n\terrorMessage?: string;\n\t/**\n\t * The display name of the context\n\t */\n\tname?: string;\n}\n\ntype CreateContextReturn<T> = [React.Provider<T>, () => T, React.Context<T>];\n\n/**\n * Creates a named context, provider, and hook.\n *\n * @param options create context options\n */\nexport function createContext<ContextType>(\n\toptions: CreateContextOptions = {},\n): CreateContextReturn<ContextType> {\n\tconst {\n\t\tstrict = true,\n\t\terrorMessage = \"useContext: `context` is undefined. Seems you forgot to wrap component within the Provider\",\n\t\tname,\n\t} = options;\n\n\tconst Context = React.createContext<ContextType | undefined>(undefined);\n\n\tContext.displayName = name;\n\n\tfunction useContext() {\n\t\tconst context = React.useContext(Context);\n\n\t\tif (!context && strict) {\n\t\t\tthrow new Error(errorMessage);\n\t\t}\n\n\t\treturn context;\n\t}\n\n\treturn [\n\t\tContext.Provider,\n\t\tuseContext,\n\t\tContext,\n\t] as CreateContextReturn<ContextType>;\n}\n\nexport const getValidChildren = (\n\tchildren: React.ReactNode,\n): React.ReactElement[] => {\n\treturn React.Children.toArray(children).filter((child) =>\n\t\tReact.isValidElement(child),\n\t) as React.ReactElement[];\n};\n",
      "type": "registry:ui"
    }
  ],
  "meta": {
    "native": true
  },
  "categories": [
    "primitives"
  ]
}